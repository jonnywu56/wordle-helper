{"ast":null,"code":"import { addDays, differenceInDays, formatISO, parseISO, startOfDay } from 'date-fns';\nimport { default as GraphemeSplitter } from 'grapheme-splitter';\nimport queryString from 'query-string';\nimport { ENABLE_ARCHIVED_GAMES } from '../constants/settings';\nimport { NOT_CONTAINED_MESSAGE, WRONG_SPOT_MESSAGE } from '../constants/strings';\nimport { VALID_GUESSES } from '../constants/validGuesses';\nimport { WORDS } from '../constants/wordlist';\nimport { getToday } from './dateutils';\nimport { getGuessStatuses } from './statuses'; // 1 January 2022 Game Epoch\n\nexport const firstGameDate = new Date(2022, 0);\nexport const periodInDays = 1;\nexport const isWordInWordList = word => {\n  return WORDS.includes(localeAwareLowerCase(word)) || VALID_GUESSES.includes(localeAwareLowerCase(word));\n};\nexport const isWinningWord = word => {\n  return solution === word;\n};\n\nconst checkValidGuess = (validWord, guess, statuses) => {\n  var validWordArray = Array.from(validWord);\n\n  for (let i = 0; i < validWordArray.length; i++) {\n    print(validWord);\n\n    if (statuses[i] === 'correct') {\n      if (validWordArray[i] !== guess[i]) {\n        return false;\n      }\n    } else if (statuses[i] === 'present') {\n      var found = false;\n\n      for (let j = 0; j < validWordArray.length; j++) {\n        if (i !== j && // can't be same index b/c yellow\n        validWordArray[j] === guess[i] && // make sure match\n        statuses[j] != 'green') // isn't reserved for green\n          found = true;\n        validWordArray[j] = '';\n        break;\n      }\n\n      if (!found) {\n        return false;\n      }\n    } else {\n      if (guess.includes(validWordArray[i])) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\nexport const getValidGuesses = (validWords, guess, statuses) => {\n  console.log('Before guess', validWords.length);\n  var remainder = validWords.filter(validWord => checkValidGuess(validWord, guess, statuses));\n  console.log('after guess', remainder.length);\n  return remainder;\n}; // build a set of previously revealed letters - present and correct\n// guess must use correct letters in that space and any other revealed letters\n// also check if all revealed instances of a letter are used (i.e. two C's)\n\nexport const findFirstUnusedReveal = (word, guesses) => {\n  if (guesses.length === 0) {\n    return false;\n  }\n\n  const lettersLeftArray = new Array();\n  const guess = guesses[guesses.length - 1];\n  const statuses = getGuessStatuses(solution, guess);\n  const splitWord = unicodeSplit(word);\n  const splitGuess = unicodeSplit(guess);\n\n  for (let i = 0; i < splitGuess.length; i++) {\n    if (statuses[i] === 'correct' || statuses[i] === 'present') {\n      lettersLeftArray.push(splitGuess[i]);\n    }\n\n    if (statuses[i] === 'correct' && splitWord[i] !== splitGuess[i]) {\n      return WRONG_SPOT_MESSAGE(splitGuess[i], i + 1);\n    }\n  } // check for the first unused letter, taking duplicate letters\n  // into account - see issue #198\n\n\n  let n;\n\n  for (const letter of splitWord) {\n    n = lettersLeftArray.indexOf(letter);\n\n    if (n !== -1) {\n      lettersLeftArray.splice(n, 1);\n    }\n  }\n\n  if (lettersLeftArray.length > 0) {\n    return NOT_CONTAINED_MESSAGE(lettersLeftArray[0]);\n  }\n\n  return false;\n};\nexport const unicodeSplit = word => {\n  return new GraphemeSplitter().splitGraphemes(word);\n};\nexport const unicodeLength = word => {\n  return unicodeSplit(word).length;\n};\nexport const localeAwareLowerCase = text => {\n  return process.env.REACT_APP_LOCALE_STRING ? text.toLocaleLowerCase(process.env.REACT_APP_LOCALE_STRING) : text.toLowerCase();\n};\nexport const localeAwareUpperCase = text => {\n  return process.env.REACT_APP_LOCALE_STRING ? text.toLocaleUpperCase(process.env.REACT_APP_LOCALE_STRING) : text.toUpperCase();\n};\nexport const getLastGameDate = today => {\n  const t = startOfDay(today);\n  let daysSinceLastGame = differenceInDays(firstGameDate, t) % periodInDays;\n  return addDays(t, -daysSinceLastGame);\n};\nexport const getNextGameDate = today => {\n  return addDays(getLastGameDate(today), periodInDays);\n};\nexport const isValidGameDate = date => {\n  if (date < firstGameDate || date > getToday()) {\n    return false;\n  }\n\n  return differenceInDays(firstGameDate, date) % periodInDays === 0;\n};\nexport const getIndex = gameDate => {\n  let start = firstGameDate;\n  let index = -1;\n\n  do {\n    index++;\n    start = addDays(start, periodInDays);\n  } while (start <= gameDate);\n\n  return index;\n};\nexport const getWordOfDay = index => {\n  if (index < 0) {\n    throw new Error('Invalid index');\n  }\n\n  return localeAwareUpperCase(WORDS[index % WORDS.length]);\n};\nexport const getSolution = gameDate => {\n  const nextGameDate = getNextGameDate(gameDate);\n  const index = getIndex(gameDate);\n  const wordOfTheDay = getWordOfDay(index);\n  return {\n    solution: wordOfTheDay,\n    solutionGameDate: gameDate,\n    solutionIndex: index,\n    tomorrow: nextGameDate.valueOf()\n  };\n};\nexport const getGameDate = () => {\n  if (getIsLatestGame()) {\n    return getToday();\n  }\n\n  const parsed = queryString.parse(window.location.search);\n\n  try {\n    const d = startOfDay(parseISO(parsed.d.toString()));\n\n    if (d >= getToday() || d < firstGameDate) {\n      setGameDate(getToday());\n    }\n\n    return d;\n  } catch (e) {\n    console.log(e);\n    return getToday();\n  }\n};\nexport const setGameDate = d => {\n  try {\n    if (d < getToday()) {\n      window.location.href = '/?d=' + formatISO(d, {\n        representation: 'date'\n      });\n      return;\n    }\n  } catch (e) {\n    console.log(e);\n  }\n\n  window.location.href = '/';\n};\nexport const getIsLatestGame = () => {\n  if (!ENABLE_ARCHIVED_GAMES) {\n    return true;\n  }\n\n  const parsed = queryString.parse(window.location.search);\n  return parsed === null || !('d' in parsed);\n};\nexport const {\n  solution,\n  solutionGameDate,\n  solutionIndex,\n  tomorrow\n} = getSolution(getGameDate());","map":{"version":3,"sources":["/Users/Jonny/Desktop/wordle-solver/src/lib/words.ts"],"names":["addDays","differenceInDays","formatISO","parseISO","startOfDay","default","GraphemeSplitter","queryString","ENABLE_ARCHIVED_GAMES","NOT_CONTAINED_MESSAGE","WRONG_SPOT_MESSAGE","VALID_GUESSES","WORDS","getToday","getGuessStatuses","firstGameDate","Date","periodInDays","isWordInWordList","word","includes","localeAwareLowerCase","isWinningWord","solution","checkValidGuess","validWord","guess","statuses","validWordArray","Array","from","i","length","print","found","j","getValidGuesses","validWords","console","log","remainder","filter","findFirstUnusedReveal","guesses","lettersLeftArray","splitWord","unicodeSplit","splitGuess","push","n","letter","indexOf","splice","splitGraphemes","unicodeLength","text","process","env","REACT_APP_LOCALE_STRING","toLocaleLowerCase","toLowerCase","localeAwareUpperCase","toLocaleUpperCase","toUpperCase","getLastGameDate","today","t","daysSinceLastGame","getNextGameDate","isValidGameDate","date","getIndex","gameDate","start","index","getWordOfDay","Error","getSolution","nextGameDate","wordOfTheDay","solutionGameDate","solutionIndex","tomorrow","valueOf","getGameDate","getIsLatestGame","parsed","parse","window","location","search","d","toString","setGameDate","e","href","representation"],"mappings":"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","sourcesContent":["import {\n  addDays,\n  differenceInDays,\n  formatISO,\n  parseISO,\n  startOfDay,\n} from 'date-fns'\nimport { default as GraphemeSplitter } from 'grapheme-splitter'\nimport queryString from 'query-string'\n\nimport { ENABLE_ARCHIVED_GAMES } from '../constants/settings'\nimport { NOT_CONTAINED_MESSAGE, WRONG_SPOT_MESSAGE } from '../constants/strings'\nimport { VALID_GUESSES } from '../constants/validGuesses'\nimport { WORDS } from '../constants/wordlist'\nimport { getToday } from './dateutils'\nimport { getGuessStatuses } from './statuses'\n\n// 1 January 2022 Game Epoch\nexport const firstGameDate = new Date(2022, 0)\nexport const periodInDays = 1\n\nexport const isWordInWordList = (word: string) => {\n  return (\n    WORDS.includes(localeAwareLowerCase(word)) ||\n    VALID_GUESSES.includes(localeAwareLowerCase(word))\n  )\n}\n\nexport const isWinningWord = (word: string) => {\n  return solution === word\n}\n\nconst checkValidGuess = (\n  validWord: string,\n  guess: string,\n  statuses: Array<string>\n) => {\n  var validWordArray = Array.from(validWord)\n  for (let i = 0; i < validWordArray.length; i++) {\n    print(validWord)\n    if (statuses[i] === 'correct') {\n      if (validWordArray[i] !== guess[i]) {\n        return false\n      }\n    } else if (statuses[i] === 'present') {\n      var found = false\n      for (let j = 0; j < validWordArray.length; j++) {\n        if (\n          i !== j && // can't be same index b/c yellow\n          validWordArray[j] === guess[i] && // make sure match\n          statuses[j] != 'green'\n        )\n          // isn't reserved for green\n          found = true\n        validWordArray[j] = ''\n        break\n      }\n      if (!found) {\n        return false\n      }\n    } else {\n      if (guess.includes(validWordArray[i])) {\n        return false\n      }\n    }\n  }\n  return true\n}\n\nexport const getValidGuesses = (\n  validWords: Array<string>,\n  guess: string,\n  statuses: Array<string>\n) => {\n  console.log('Before guess', validWords.length)\n  var remainder = validWords.filter((validWord) =>\n    checkValidGuess(validWord, guess, statuses)\n  )\n  console.log('after guess', remainder.length)\n  return remainder\n}\n\n// build a set of previously revealed letters - present and correct\n// guess must use correct letters in that space and any other revealed letters\n// also check if all revealed instances of a letter are used (i.e. two C's)\nexport const findFirstUnusedReveal = (word: string, guesses: string[]) => {\n  if (guesses.length === 0) {\n    return false\n  }\n\n  const lettersLeftArray = new Array<string>()\n  const guess = guesses[guesses.length - 1]\n  const statuses = getGuessStatuses(solution, guess)\n  const splitWord = unicodeSplit(word)\n  const splitGuess = unicodeSplit(guess)\n\n  for (let i = 0; i < splitGuess.length; i++) {\n    if (statuses[i] === 'correct' || statuses[i] === 'present') {\n      lettersLeftArray.push(splitGuess[i])\n    }\n    if (statuses[i] === 'correct' && splitWord[i] !== splitGuess[i]) {\n      return WRONG_SPOT_MESSAGE(splitGuess[i], i + 1)\n    }\n  }\n\n  // check for the first unused letter, taking duplicate letters\n  // into account - see issue #198\n  let n\n  for (const letter of splitWord) {\n    n = lettersLeftArray.indexOf(letter)\n    if (n !== -1) {\n      lettersLeftArray.splice(n, 1)\n    }\n  }\n\n  if (lettersLeftArray.length > 0) {\n    return NOT_CONTAINED_MESSAGE(lettersLeftArray[0])\n  }\n  return false\n}\n\nexport const unicodeSplit = (word: string) => {\n  return new GraphemeSplitter().splitGraphemes(word)\n}\n\nexport const unicodeLength = (word: string) => {\n  return unicodeSplit(word).length\n}\n\nexport const localeAwareLowerCase = (text: string) => {\n  return process.env.REACT_APP_LOCALE_STRING\n    ? text.toLocaleLowerCase(process.env.REACT_APP_LOCALE_STRING)\n    : text.toLowerCase()\n}\n\nexport const localeAwareUpperCase = (text: string) => {\n  return process.env.REACT_APP_LOCALE_STRING\n    ? text.toLocaleUpperCase(process.env.REACT_APP_LOCALE_STRING)\n    : text.toUpperCase()\n}\n\nexport const getLastGameDate = (today: Date) => {\n  const t = startOfDay(today)\n  let daysSinceLastGame = differenceInDays(firstGameDate, t) % periodInDays\n  return addDays(t, -daysSinceLastGame)\n}\n\nexport const getNextGameDate = (today: Date) => {\n  return addDays(getLastGameDate(today), periodInDays)\n}\n\nexport const isValidGameDate = (date: Date) => {\n  if (date < firstGameDate || date > getToday()) {\n    return false\n  }\n\n  return differenceInDays(firstGameDate, date) % periodInDays === 0\n}\n\nexport const getIndex = (gameDate: Date) => {\n  let start = firstGameDate\n  let index = -1\n  do {\n    index++\n    start = addDays(start, periodInDays)\n  } while (start <= gameDate)\n\n  return index\n}\n\nexport const getWordOfDay = (index: number) => {\n  if (index < 0) {\n    throw new Error('Invalid index')\n  }\n\n  return localeAwareUpperCase(WORDS[index % WORDS.length])\n}\n\nexport const getSolution = (gameDate: Date) => {\n  const nextGameDate = getNextGameDate(gameDate)\n  const index = getIndex(gameDate)\n  const wordOfTheDay = getWordOfDay(index)\n  return {\n    solution: wordOfTheDay,\n    solutionGameDate: gameDate,\n    solutionIndex: index,\n    tomorrow: nextGameDate.valueOf(),\n  }\n}\n\nexport const getGameDate = () => {\n  if (getIsLatestGame()) {\n    return getToday()\n  }\n\n  const parsed = queryString.parse(window.location.search)\n  try {\n    const d = startOfDay(parseISO(parsed.d!.toString()))\n    if (d >= getToday() || d < firstGameDate) {\n      setGameDate(getToday())\n    }\n    return d\n  } catch (e) {\n    console.log(e)\n    return getToday()\n  }\n}\n\nexport const setGameDate = (d: Date) => {\n  try {\n    if (d < getToday()) {\n      window.location.href = '/?d=' + formatISO(d, { representation: 'date' })\n      return\n    }\n  } catch (e) {\n    console.log(e)\n  }\n  window.location.href = '/'\n}\n\nexport const getIsLatestGame = () => {\n  if (!ENABLE_ARCHIVED_GAMES) {\n    return true\n  }\n  const parsed = queryString.parse(window.location.search)\n  return parsed === null || !('d' in parsed)\n}\n\nexport const { solution, solutionGameDate, solutionIndex, tomorrow } =\n  getSolution(getGameDate())\n"]},"metadata":{},"sourceType":"module"}