{"ast":null,"code":"import { addDays, differenceInDays, formatISO, parseISO, startOfDay } from 'date-fns';\nimport { default as GraphemeSplitter } from 'grapheme-splitter';\nimport queryString from 'query-string';\nimport { ENABLE_ARCHIVED_GAMES } from '../constants/settings';\nimport { NOT_CONTAINED_MESSAGE, WRONG_SPOT_MESSAGE } from '../constants/strings';\nimport { VALID_GUESSES } from '../constants/validGuesses';\nimport { WORDS } from '../constants/wordlist';\nimport { getToday } from './dateutils';\nimport { getGuessStatuses } from './statuses'; // 1 January 2022 Game Epoch\n\nexport const firstGameDate = new Date(2022, 0);\nexport const periodInDays = 1;\nexport const isWordInWordList = word => {\n  return WORDS.includes(localeAwareLowerCase(word)) || VALID_GUESSES.includes(localeAwareLowerCase(word));\n};\nexport const isWinningWord = word => {\n  return solution === word;\n};\nexport const getValidGuesses = (validWords, guess, statuses) => {\n  var res = [];\n\n  for (var i in validWords) {\n    console.log(validWords[i]);\n  }\n\n  console.log(validWords, guess, statuses);\n  return;\n}; // build a set of previously revealed letters - present and correct\n// guess must use correct letters in that space and any other revealed letters\n// also check if all revealed instances of a letter are used (i.e. two C's)\n\nexport const findFirstUnusedReveal = (word, guesses) => {\n  if (guesses.length === 0) {\n    return false;\n  }\n\n  const lettersLeftArray = new Array();\n  const guess = guesses[guesses.length - 1];\n  const statuses = getGuessStatuses(solution, guess);\n  const splitWord = unicodeSplit(word);\n  const splitGuess = unicodeSplit(guess);\n\n  for (let i = 0; i < splitGuess.length; i++) {\n    if (statuses[i] === 'correct' || statuses[i] === 'present') {\n      lettersLeftArray.push(splitGuess[i]);\n    }\n\n    if (statuses[i] === 'correct' && splitWord[i] !== splitGuess[i]) {\n      return WRONG_SPOT_MESSAGE(splitGuess[i], i + 1);\n    }\n  } // check for the first unused letter, taking duplicate letters\n  // into account - see issue #198\n\n\n  let n;\n\n  for (const letter of splitWord) {\n    n = lettersLeftArray.indexOf(letter);\n\n    if (n !== -1) {\n      lettersLeftArray.splice(n, 1);\n    }\n  }\n\n  if (lettersLeftArray.length > 0) {\n    return NOT_CONTAINED_MESSAGE(lettersLeftArray[0]);\n  }\n\n  return false;\n};\nexport const unicodeSplit = word => {\n  return new GraphemeSplitter().splitGraphemes(word);\n};\nexport const unicodeLength = word => {\n  return unicodeSplit(word).length;\n};\nexport const localeAwareLowerCase = text => {\n  return process.env.REACT_APP_LOCALE_STRING ? text.toLocaleLowerCase(process.env.REACT_APP_LOCALE_STRING) : text.toLowerCase();\n};\nexport const localeAwareUpperCase = text => {\n  return process.env.REACT_APP_LOCALE_STRING ? text.toLocaleUpperCase(process.env.REACT_APP_LOCALE_STRING) : text.toUpperCase();\n};\nexport const getLastGameDate = today => {\n  const t = startOfDay(today);\n  let daysSinceLastGame = differenceInDays(firstGameDate, t) % periodInDays;\n  return addDays(t, -daysSinceLastGame);\n};\nexport const getNextGameDate = today => {\n  return addDays(getLastGameDate(today), periodInDays);\n};\nexport const isValidGameDate = date => {\n  if (date < firstGameDate || date > getToday()) {\n    return false;\n  }\n\n  return differenceInDays(firstGameDate, date) % periodInDays === 0;\n};\nexport const getIndex = gameDate => {\n  let start = firstGameDate;\n  let index = -1;\n\n  do {\n    index++;\n    start = addDays(start, periodInDays);\n  } while (start <= gameDate);\n\n  return index;\n};\nexport const getWordOfDay = index => {\n  if (index < 0) {\n    throw new Error('Invalid index');\n  }\n\n  return localeAwareUpperCase(WORDS[index % WORDS.length]);\n};\nexport const getSolution = gameDate => {\n  const nextGameDate = getNextGameDate(gameDate);\n  const index = getIndex(gameDate);\n  const wordOfTheDay = getWordOfDay(index);\n  return {\n    solution: wordOfTheDay,\n    solutionGameDate: gameDate,\n    solutionIndex: index,\n    tomorrow: nextGameDate.valueOf()\n  };\n};\nexport const getGameDate = () => {\n  if (getIsLatestGame()) {\n    return getToday();\n  }\n\n  const parsed = queryString.parse(window.location.search);\n\n  try {\n    const d = startOfDay(parseISO(parsed.d.toString()));\n\n    if (d >= getToday() || d < firstGameDate) {\n      setGameDate(getToday());\n    }\n\n    return d;\n  } catch (e) {\n    console.log(e);\n    return getToday();\n  }\n};\nexport const setGameDate = d => {\n  try {\n    if (d < getToday()) {\n      window.location.href = '/?d=' + formatISO(d, {\n        representation: 'date'\n      });\n      return;\n    }\n  } catch (e) {\n    console.log(e);\n  }\n\n  window.location.href = '/';\n};\nexport const getIsLatestGame = () => {\n  if (!ENABLE_ARCHIVED_GAMES) {\n    return true;\n  }\n\n  const parsed = queryString.parse(window.location.search);\n  return parsed === null || !('d' in parsed);\n};\nexport const {\n  solution,\n  solutionGameDate,\n  solutionIndex,\n  tomorrow\n} = getSolution(getGameDate());","map":{"version":3,"sources":["/Users/Jonny/Desktop/wordle-solver/src/lib/words.ts"],"names":["addDays","differenceInDays","formatISO","parseISO","startOfDay","default","GraphemeSplitter","queryString","ENABLE_ARCHIVED_GAMES","NOT_CONTAINED_MESSAGE","WRONG_SPOT_MESSAGE","VALID_GUESSES","WORDS","getToday","getGuessStatuses","firstGameDate","Date","periodInDays","isWordInWordList","word","includes","localeAwareLowerCase","isWinningWord","solution","getValidGuesses","validWords","guess","statuses","res","i","console","log","findFirstUnusedReveal","guesses","length","lettersLeftArray","Array","splitWord","unicodeSplit","splitGuess","push","n","letter","indexOf","splice","splitGraphemes","unicodeLength","text","process","env","REACT_APP_LOCALE_STRING","toLocaleLowerCase","toLowerCase","localeAwareUpperCase","toLocaleUpperCase","toUpperCase","getLastGameDate","today","t","daysSinceLastGame","getNextGameDate","isValidGameDate","date","getIndex","gameDate","start","index","getWordOfDay","Error","getSolution","nextGameDate","wordOfTheDay","solutionGameDate","solutionIndex","tomorrow","valueOf","getGameDate","getIsLatestGame","parsed","parse","window","location","search","d","toString","setGameDate","e","href","representation"],"mappings":"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","sourcesContent":["import {\n  addDays,\n  differenceInDays,\n  formatISO,\n  parseISO,\n  startOfDay,\n} from 'date-fns'\nimport { default as GraphemeSplitter } from 'grapheme-splitter'\nimport queryString from 'query-string'\n\nimport { ENABLE_ARCHIVED_GAMES } from '../constants/settings'\nimport { NOT_CONTAINED_MESSAGE, WRONG_SPOT_MESSAGE } from '../constants/strings'\nimport { VALID_GUESSES } from '../constants/validGuesses'\nimport { WORDS } from '../constants/wordlist'\nimport { getToday } from './dateutils'\nimport { getGuessStatuses } from './statuses'\n\n// 1 January 2022 Game Epoch\nexport const firstGameDate = new Date(2022, 0)\nexport const periodInDays = 1\n\nexport const isWordInWordList = (word: string) => {\n  return (\n    WORDS.includes(localeAwareLowerCase(word)) ||\n    VALID_GUESSES.includes(localeAwareLowerCase(word))\n  )\n}\n\nexport const isWinningWord = (word: string) => {\n  return solution === word\n}\n\nexport const getValidGuesses = (\n  validWords: Array<string>,\n  guess: string,\n  statuses: Array<string>\n) => {\n  var res = []\n  for (var i in validWords) {\n    console.log(validWords[i])\n  }\n  console.log(validWords, guess, statuses)\n\n  return\n}\n\n// build a set of previously revealed letters - present and correct\n// guess must use correct letters in that space and any other revealed letters\n// also check if all revealed instances of a letter are used (i.e. two C's)\nexport const findFirstUnusedReveal = (word: string, guesses: string[]) => {\n  if (guesses.length === 0) {\n    return false\n  }\n\n  const lettersLeftArray = new Array<string>()\n  const guess = guesses[guesses.length - 1]\n  const statuses = getGuessStatuses(solution, guess)\n  const splitWord = unicodeSplit(word)\n  const splitGuess = unicodeSplit(guess)\n\n  for (let i = 0; i < splitGuess.length; i++) {\n    if (statuses[i] === 'correct' || statuses[i] === 'present') {\n      lettersLeftArray.push(splitGuess[i])\n    }\n    if (statuses[i] === 'correct' && splitWord[i] !== splitGuess[i]) {\n      return WRONG_SPOT_MESSAGE(splitGuess[i], i + 1)\n    }\n  }\n\n  // check for the first unused letter, taking duplicate letters\n  // into account - see issue #198\n  let n\n  for (const letter of splitWord) {\n    n = lettersLeftArray.indexOf(letter)\n    if (n !== -1) {\n      lettersLeftArray.splice(n, 1)\n    }\n  }\n\n  if (lettersLeftArray.length > 0) {\n    return NOT_CONTAINED_MESSAGE(lettersLeftArray[0])\n  }\n  return false\n}\n\nexport const unicodeSplit = (word: string) => {\n  return new GraphemeSplitter().splitGraphemes(word)\n}\n\nexport const unicodeLength = (word: string) => {\n  return unicodeSplit(word).length\n}\n\nexport const localeAwareLowerCase = (text: string) => {\n  return process.env.REACT_APP_LOCALE_STRING\n    ? text.toLocaleLowerCase(process.env.REACT_APP_LOCALE_STRING)\n    : text.toLowerCase()\n}\n\nexport const localeAwareUpperCase = (text: string) => {\n  return process.env.REACT_APP_LOCALE_STRING\n    ? text.toLocaleUpperCase(process.env.REACT_APP_LOCALE_STRING)\n    : text.toUpperCase()\n}\n\nexport const getLastGameDate = (today: Date) => {\n  const t = startOfDay(today)\n  let daysSinceLastGame = differenceInDays(firstGameDate, t) % periodInDays\n  return addDays(t, -daysSinceLastGame)\n}\n\nexport const getNextGameDate = (today: Date) => {\n  return addDays(getLastGameDate(today), periodInDays)\n}\n\nexport const isValidGameDate = (date: Date) => {\n  if (date < firstGameDate || date > getToday()) {\n    return false\n  }\n\n  return differenceInDays(firstGameDate, date) % periodInDays === 0\n}\n\nexport const getIndex = (gameDate: Date) => {\n  let start = firstGameDate\n  let index = -1\n  do {\n    index++\n    start = addDays(start, periodInDays)\n  } while (start <= gameDate)\n\n  return index\n}\n\nexport const getWordOfDay = (index: number) => {\n  if (index < 0) {\n    throw new Error('Invalid index')\n  }\n\n  return localeAwareUpperCase(WORDS[index % WORDS.length])\n}\n\nexport const getSolution = (gameDate: Date) => {\n  const nextGameDate = getNextGameDate(gameDate)\n  const index = getIndex(gameDate)\n  const wordOfTheDay = getWordOfDay(index)\n  return {\n    solution: wordOfTheDay,\n    solutionGameDate: gameDate,\n    solutionIndex: index,\n    tomorrow: nextGameDate.valueOf(),\n  }\n}\n\nexport const getGameDate = () => {\n  if (getIsLatestGame()) {\n    return getToday()\n  }\n\n  const parsed = queryString.parse(window.location.search)\n  try {\n    const d = startOfDay(parseISO(parsed.d!.toString()))\n    if (d >= getToday() || d < firstGameDate) {\n      setGameDate(getToday())\n    }\n    return d\n  } catch (e) {\n    console.log(e)\n    return getToday()\n  }\n}\n\nexport const setGameDate = (d: Date) => {\n  try {\n    if (d < getToday()) {\n      window.location.href = '/?d=' + formatISO(d, { representation: 'date' })\n      return\n    }\n  } catch (e) {\n    console.log(e)\n  }\n  window.location.href = '/'\n}\n\nexport const getIsLatestGame = () => {\n  if (!ENABLE_ARCHIVED_GAMES) {\n    return true\n  }\n  const parsed = queryString.parse(window.location.search)\n  return parsed === null || !('d' in parsed)\n}\n\nexport const { solution, solutionGameDate, solutionIndex, tomorrow } =\n  getSolution(getGameDate())\n"]},"metadata":{},"sourceType":"module"}